import base64
import os
import glob
from datetime import date
from tracemalloc import start
import pandas as pd
import yfinance as yf
from urllib.parse import quote as urlquote
from flask import Flask, send_from_directory
from dash import Dash, dcc, html
from dash.dependencies import Input, Output, State
import dash_bootstrap_components as dbc
from dash import dash_table as dt




class ManipulateFile:
    UPLOAD_DIRECTORY = "malwareGUI/app_uploaded_files"

    def disassembleFile(sourcePath, destinationPath):
        ''' 
        file_path = '~/binaries/benign/'
        output_path = '~/binaries/dumps/'
        '''

        file_path = sourcePath
        output_path = destinationPath
        binaries_list = os.listdir(file_path)

        # file path to each binary in directory
        binaries_file_path = []

        # file path to output for each binary
        output_list = []

        # list of bfd for executables
        bfd_list = []

        for i in range(len(binaries_list)):
            binaries_file_path.append(file_path + binaries_list[i])
            output_list.append('> ' + output_path + binaries_list[i].replace('.exe', '') + '.txt')

        debug = '-d '

        command_subsection = 'sudo objdump -M intel -b '

        for i in range(len(binaries_list)):
            bfd = ''
            bfd_cmd = 'objdump -f ' + binaries_file_path[i] + ' > tmp.txt'
            os.system(bfd_cmd)
            f = open("tmp.txt", "r")

            # just search file for bfd format

            pei = 'pei-x86-64'
            pe = 'pe-x86-64'

            if pei in f.read():
                bfd = pei + ' '

            elif pe in f.read():
                bfd = pe + ' '

            bfd_list.append(bfd)

            os.remove("tmp.txt")

        for i in range(len(binaries_list)):
            command = command_subsection + bfd_list[i] + debug + binaries_file_path[i] + output_list[i]
            os.system(command)


    def save_file(name, content):
        "Decode and store a file uploaded with Plotly Dash."
        data = content.encode("utf8").split(b";base64,")[1]
        with open(os.path.join(ManipulateFile.UPLOAD_DIRECTORY, name), "wb") as fp:
            fp.write(base64.decodebytes(data))


    def uploaded_files():
        "List the files in the upload directory."
        files = []
        for filename in os.listdir(ManipulateFile.UPLOAD_DIRECTORY):
            path = os.path.join(ManipulateFile.UPLOAD_DIRECTORY, filename)
            if os.path.isfile(path) and filename != ".DS_Store":
                files.append(filename)

        return files


    def file_download_link(filename):
        "Create a Plotly Dash 'A' element that downloads a file from the app."
        location = "/download/{}".format(urlquote(filename))

        return html.A(filename, href=location)



#pandas dummy data for datatable;
today = date.today()
df = yf.download("AAPL", start='2021-12-01', end=today)



if not os.path.exists(ManipulateFile.UPLOAD_DIRECTORY):
    os.makedirs(ManipulateFile.UPLOAD_DIRECTORY)


server = Flask(__name__)
malwareApp = Dash(server=server, external_stylesheets=[dbc.themes.BOOTSTRAP])
app = malwareApp.server



#Layout of page
banner = html.Div([html.Div([html.H1("Malware Analyzer", className="text-warning text-center"), 
         html.P("Developed using Python and Machine Learning", className="text-center mb-5")])], className="bg-dark text-light p-4 text-center")

datalist = html.Div([html.Datalist(
   id="datalist"), dbc.Button("Delete", id="btnDelete")])


malwareApp.layout = html.Div([banner, html.Div([dbc.Card(
    [
        dbc.CardImg(src="https://www.cisco.com/c/en/us/products/security/advanced-malware-protection/what-is-malware/jcr:content/Grid/category_atl_9819/layout-category-atl/anchor_info_a0df.img.png/1648845856586.png", top=True),
        html.H1("File Browser", className = "mb-4"),
        html.H2("Upload"),
        dcc.Upload(
            id="upload-data",
            children=html.Div(
                ["Drag and drop or click to select a file to upload."]
            ),
            style={
                "width": "90%",
                "height": "60px",
                "lineHeight": "60px",
                "borderWidth": "1px",
                "borderStyle": "dashed",
                "borderRadius": "5px",
                "textAlign": "center",
                "margin": "10px",
            },
            multiple=True, className = "mb-4"
        ),
        html.H2("File List"),
        html.Ul(id="file-list", className = "mb-5"),
        dbc.Input(placeholder = "Enter File Name", id="userInput", className = "w-75"),
        dbc.Button("Process File", id="processBtn", className = "w-25 btn-warning"),
        dbc.Button("Disassemble", id="Disassemble", className = "w-25 btn-primary"),
        html.P(id="textContent"),
        html.P(id="textContent2")
    ],
    style={"max-width": "500px"},
), dt.DataTable(data=df.to_dict('records'), columns=[{"name": i, "id": i} for i in df.columns], page_size=20)], 
                className="d-flex align-items-center justify-content-center my-5 bg-light", id="dataTable")])




#route that downloads file when user accesses URL/download/{filename.txt}
@server.route("/download/<path:path>")
def download(path):
    "User can download file from UPLOAD_DIRECTORY"
    return send_from_directory(ManipulateFile.UPLOAD_DIRECTORY, path, as_attachment=True)



#callback function that updates file list when file is upladed
@malwareApp.callback(
    Output("file-list", "children"),
    [Input("upload-data", "filename"), Input("upload-data", "contents")],
)


def update_output(uploaded_filenames, uploaded_file_contents):
    "Save uploaded files and generate the file list."

    if uploaded_filenames is not None and uploaded_file_contents is not None:
        for name, data in zip(uploaded_filenames, uploaded_file_contents):
            ManipulateFile.save_file(name, data)

    files = ManipulateFile.uploaded_files()
    if len(files) == 0:
        return [html.Li("No files yet!")]

    elif len(files) > 5:
        path = glob.glob("malwareGUI/app_uploaded_files/*.txt")
        for file in path:
            os.remove(file)
        
        return [html.Li("No files yet!")]
        
    else:
        return [html.Li(ManipulateFile.file_download_link(filename)) for filename in files]

    

#example callback function that outputs file text when file is selected;
#--Where code for machine learning model will go, that will return results of scan--#
@malwareApp.callback(
    Output("textContent", "children"),
    Input("processBtn", "n_clicks"),
    State("userInput", "value")
)

def processText(processBtn, filename):
    files = ManipulateFile.uploaded_files()

    for i in files:
        if filename in files:
            path = os.path.join(ManipulateFile.UPLOAD_DIRECTORY, filename)
            f = open(path, "r")
            contents = f.read()    
            return "Contents of file: " + contents


    return "No file selected"



@malwareApp.callback(
    Output("textContent2", "children"),
    Input("Disassemble", "n_clicks"),
    State("userInput", "value")
)

def disassembleFile(Disassemble, filename):
    files = ManipulateFile.uploaded_files()

    for i in files:
        if filename in files:
            path = "malwareGUI/app_uploaded_files"
            destination = "malwareGUI/outputFiles/"
            ManipulateFile.disassembleFile(path, destination)
            return "Success"
    



            



if __name__ == "__main__":
    app.run(debug=False)